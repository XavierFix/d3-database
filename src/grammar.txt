  start             = entry

  entry             = space '(' space p:program+ space ')' space 
                    { return [ 

                      p.reduce(function(e, s){ 

                        e[s.op] = s.exp;
                        return e;

                      },{ }) ];

                    }

  program           = entry / clean_spec / spec / signifier

  spec              = w:signifier space ind:(entry/spec/signified/variable)+ space
                      { return {op: w, exp:[].concat.apply([], ind) } }

  clean_spec        = ('clean' colon)? space '((' space cf:function+ space '))' 
                      { return { op: 'clean', exp: cf[0].split(',').map(function(el){ return el.trim(); }) } }

  func_spec         =  sign:signifier space func:function { return {op: sign, exp:func } }


  param_hash        = space '{' space pa:params+ space '}' { return pa;  }
  params            = bs:(bare_word/string) space colon space arg:(string/number) comma* space { return [ bs, arg ] }

  signifier         = si:(string/bare_word) space colon space { return si }
  signified         = sd:(param_hash/boolean/string/number) { return sd }

  boolean           = b:('true'/'false') { return b }

  string            = space quote str:(mandatory_space/letter)+ quote space { return str.join(""); }
  letter            = [^"' \n]

  function          = f:ftext+ { return (f.join('')); }
  ftext             = [a-zA-Z0-9-.&'||'_=+-/* ] / '[' / ']'

  variable          = v:bare_word { return { variable: v } }
  bare_word         = t:text+ { return t.join(""); }
  text              = [a-zA-Z0-9-]

  number            = d:digit+ space { return +(d.join(''));  }
  digit             = [0123456789.-]

  space             = [ \n]* / !.
  mandatory_space   = [ \n]+ / !.

  colon             = [:]
  comma             = [,]
  quote             = ["']